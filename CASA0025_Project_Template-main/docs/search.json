[
  {
    "objectID": "readme.html",
    "href": "readme.html",
    "title": "",
    "section": "",
    "text": "Use this repository to host a website for your CASA0025 final project by following these stpes:\n\nclone this repository\ninstall quarto\nedit the ‘index.qmd’ file with the contents of your project\nusing terminal, navigate to the project directory and run “quarto render”\npush the changes to your github repository\non github, navigate to Settings&gt;Pages&gt;Build and Deployment. Make sure that under “Source” it says “deploy from branch”. Under “Branch”, select “Main” in the first dropdown and “Docs” under the second drop down. Then press “Save”\n\nYour website should now be available under https://{your_username}.github.io/{your_repo_name}"
  },
  {
    "objectID": "index.html#project-summary",
    "href": "index.html#project-summary",
    "title": "CROPINVEST - Crop Yield Estimator",
    "section": "Project Summary",
    "text": "Project Summary\nCROPINVEST - Crop Yield Estimator for the State of North Dakota, USA"
  },
  {
    "objectID": "index.html#problem-statement",
    "href": "index.html#problem-statement",
    "title": "CROPINVEST - Crop Yield Estimator",
    "section": "Problem Statement",
    "text": "Problem Statement\nWhat is the problem you’re trying to address using this application?"
  },
  {
    "objectID": "index.html#end-user",
    "href": "index.html#end-user",
    "title": "CROPINVEST - Crop Yield Estimator",
    "section": "End User",
    "text": "End User\nWho are you building this application for? How does it address a need this community has?"
  },
  {
    "objectID": "index.html#data",
    "href": "index.html#data",
    "title": "CROPINVEST - Crop Yield Estimator",
    "section": "Data",
    "text": "Data\nDatasets that we have used & the relevant data from the dataset which we have used are described below in detail:-\n\nUnited States Census Bureau TIGER Dataset It contains the boundary information i.e. counties of states which are the primary legal divisions units of US states.\n\nDataset: ee.ImageCollection(“TIGER/2016/Counties”)\nDataset Provider: United States Census Bureau\nData Used for our Study: STATEFP parameter of the dataset which provides the State FIPS code & the North Dakota value is used. \n\n\nUSDA NASS Cropland Data Layers It is a crop-specific land cover data layer created annually for the continental United States using moderate resolution satellite imagery and extensive agricultural ground truth.\n\nDataset: ee.FeatureCollection(“USDA/NASS/CDL”)\nDataset Provider: USDA National Agricultural Statistics Service\nData Used for our Study: cropland values for different crops of our study are used Wheat, Corn & Soybean Values provided from the Cropland Table. \n\n\nMOD13Q1.061 Terra Vegetation Indices 16-Day Global It provides Normalized Difference Vegetation Index (NDVI) value on a per pixel basis.\n\nDataset: ee.ImageCollection(“MODIS/061/MOD13Q1”)\nDataset Provider: NASA LP DAAC at the USGS EROS Center\nData Used for our Study: NDVI parameter of the dataset which provides the Normalized Difference Vegetation Index. \n\n\nGRIDMET:Gridded Surface Meteorological Dataset It provides the high spatial resolution (~4-km) daily surface fields of temperature, precipitation, winds, humidity and radiation across the contiguous United States from 1979.\n\nDataset: ee.ImageCollection(“IDAHO_EPSCOR/GRIDMET”)\nDataset Provider: USDA National Agricultural Statistics Service\nData Used for our Study: pr parameter of the dataset which provides the ‘Precipitation amount’ in mm (daily total) \n\n\nSentinel-1 SAR GRD It contains the boundary information i.e. counties of states which are the primary legal divisions units of US states.\n\nDataset: ee.ImageCollection(“COPERNICUS/S1_GRD”)\nDataset Provider: European Union/ESA/Copernicus\nData Used for our Study: VV parameter of the dataset which provides ‘Single co-polarization, vertical transmit/vertical receive’ in dB. \n\nSPL3SMP_E.005 SMAP L3 Radiometer Global Daily 9km Soil Moisture It provides a daily composite of global land surface conditions retrieved by the Soil Moisture Active Passive (SMAP) L-Band radiometer. The daily data here were collected from the descending (local solar time of 6 am) and ascending (local solar time of 6 pm) passes.\n\nDataset: ee.ImageCollection(“NASA/SMAP/SPL3SMP_E/005”)\nDataset Provider: Google and NSIDC\nData Used for our Study: soil_moisture_am & soil_moisture_pmparameter of the dataset which provides ’Retrieved soil moisture estimate from the disaggregated/downscaled vertical polarization brightness temperature at 9-km grid cell one at AM overpass & other at PM overpass.in dB. \n\nMOD11A1.061 Terra Land Surface Temperature MOD11A1 V6.1 product provides daily land surface temperature (LST) along with other parameters.\n\nDataset: ee.ImageCollection(“NASA/SMAP/SPL3SMP_E/005”)\nDataset Provider: NASA LP DAAC at the USGS EROS Center\nData Used for our Study: LST_Day_1km & LST_Night_1kmparameter of the dataset which provides ‘Daytime Land Surface Temperature’ & Daytime Land Surface Temperature’ both in Kelvin (K). \n\nMCD18C2.061 Photosynthetically Active Radiation Daily 3 hour The MCD18C2 Version 6.1 is a Moderate Resolution Imaging Spectroradiometer (MODIS) Terra and Aqua combined Photosynthetically Active Radiation (PAR) gridded Level 3 product produced daily at 0.05 degree (5,600 meters at the equator) resolution with estimates of PAR every 3 hours.\n\nDataset: ee.ImageCollection(“MODIS/061/MCD18C2”)\nDataset Provider: NASA LP DAAC at the USGS EROS Center\nData Used for our Study: GMT_1200_PAR parameter of the dataset which provides ‘Total PAR at GMT 12:00’.PAR is incident solar radiation in the visible spectrum (400-700 nanometers) and is an important variable in land-surface models having use in agriculture & other scientific applications. \n\nMOD16A2GF.061: Terra Net Evapotranspiration It includes inputs of daily meteorological reanalysis data along with MODIS remotely sensed data products such as vegetation property dynamics, albedo, and land cover. The pixel values for the two Evapotranspiration layers (ET and PET) are the sum of all eight days within the composite period, and the pixel values for the two Latent Heat layers (LE and PLE) are the average of all eight days within the composite peri.\n\nDataset: ee.ImageCollection(“MODIS/061/MOD16A2GF”)\nDataset Provider: NASA LP DAAC at the USGS EROS Center\nData Used for our Study: ET parameter of the dataset which provides ‘Total evapotranspiration’ in kg/m^2/8day.s."
  },
  {
    "objectID": "index.html#methodology",
    "href": "index.html#methodology",
    "title": "CROPINVEST - Crop Yield Estimator",
    "section": "Methodology",
    "text": "Methodology\nPrevious studies showed that RF is an effective and universal machine learning method for crop yield prediction on a regional and global scale with high accuracy and precision and ease of use (Jeong et al., 2016.; Prasad et al., 2021).\n\nBuilding Random Forest Model:\n\nPrepare original CSV including the three types of crop among several X variables and Y variable (the crop yield)\nPrepare training/validation data\nUse the training data to train three different RF Models in GEE\n\n\n\nValidation\nTo get the performance of our models, we can use the test data from the previous split. We used R square and Root Mean Squared Error (RMSE) to validate our models. There are some graphs showing these metrics:\n:::{.column-page}\n\n  &lt;a::: d Wi\n\n**Inte\nface**nterface\nHere is a presentation to show, how our ap l\n\n \n\nCropInvest-Buradi a::: d Wani/ifram&gt;"
  },
  {
    "objectID": "index.html#the-application",
    "href": "index.html#the-application",
    "title": "CROPINVEST - Crop Yield Estimator",
    "section": "The Application",
    "text": "The Application\n\n&lt;iframe src=‘https://songzimeng.users.earthengine.app/view/north-dakota-crop-yield’ width=‘100%’ height=‘700px’&gt;&lt;/frame&gt;"
  },
  {
    "objectID": "index.html#how-it-works",
    "href": "index.html#how-it-works",
    "title": "CROPINVEST - Crop Yield Estimator",
    "section": "How it Works",
    "text": "How it Works\n\nData Extraction Code:\n\nHere we use the Python environment to extract the data from different datasets using Google Earth Engine API\nAfterwards, we first use the crop-specific land cover data to distinguish different crops- wheat, soybean or corn for each county in North Dakota.\nFurther, NDVI, Precipitation, SAR, Soil Moisture & other values are used to get the county-wise values from the year 2000-2024.\nAfterwards, the Yield data is obtained from the United States Department of Agriculture for each of the years and a final dataset is obtained which has all the X Variables (GEOID,NDVI,PA,SAR,SMS_AM,LST_DAY,SMS_PM,LST_NIGHT,PAR,ET) & Y variable (YIELD).\n\n\npip install earthengine-api\nimport ee\ndef processYear(year):\n    # Load the CDL dataset for the given year\n    dataset = ee.ImageCollection('USDA/NASS/CDL')\\\n                .filter(ee.Filter.date(f'{year}-01-01', f'{year}-12-31'))\\\n                .first()\n    crop_landcover = dataset.select('cropland')\n\n    # Filter for North Dakota counties\n    #`STATEFP` parameter of the dataset which provides the State FIPS code & the North Dakota value is used.\n    counties = ee.FeatureCollection('TIGER/2016/Counties')\n    nd = counties.filter(ee.Filter.eq('STATEFP', '38'))\n    \n    # Identify corn areas in North Dakota\n    #`cropland` values for different crops of our study are used Wheat, Corn & Soybean Values provided from the Cropland Table.\n    corn = crop_landcover.eq(1).Or(crop_landcover.eq(12)).Or(crop_landcover.eq(13))\n    masked_corn = crop_landcover.updateMask(corn).clipToCollection(nd)\n\n    # Calculate NDVI for corn areas using MODIS data\n    #`NDVI` parameter of the dataset and we obtain the mean over the growth period of the crop\n    NDVI_dataset = ee.ImageCollection('MODIS/061/MOD13Q1')\\\n                    .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\n    ndvi = NDVI_dataset.select('NDVI')\n    mean_ndvi = ndvi.mean().rename('NDVI')\n    cornNDVI = mean_ndvi.updateMask(masked_corn)\n    \n    # Calculate precipitation using GRIDMET data\n    #`pr` parameter of the dataset which provides the 'Precipitation amount' in mm (daily total)\n    precipitation_dataset = ee.ImageCollection(\"IDAHO_EPSCOR/GRIDMET\")\\\n                             .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\\\n                             .select('pr')\n    mean_precipitation = precipitation_dataset.mean().rename('PA')\n\n    # Load Sentinel-1 C-band SAR Image Collection for the given year, select VV polarization\n    #`VV` parameter of the dataset which provides 'Single co-polarization, vertical transmit/vertical receive' in dB.\n    s1_dataset = ee.ImageCollection(\"COPERNICUS/S1_GRD\")\\\n                   .filter(ee.Filter.eq('instrumentMode', 'IW'))\\\n                   .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))\\\n                   .filter(ee.Filter.date(f'{year}-01-01', f'{year}-12-31'))\\\n                   .select('VV')\n    mean_s1_vv = s1_dataset.mean().rename('SAR')\n\n    # Load Radiometer Global Daily 9 km Soil Moisture AM\n    #`soil_moisture_am` & `soil_moisture_pm` parameter of the dataset which provides 'Retrieved soil moisture estimate from the\n    # disaggregated/downscaled vertical polarization brightness temperature at 9-km grid cell one at AM overpass & other at  PM overpass. in dB.\n    smap_dataset = ee.ImageCollection(\"NASA/SMAP/SPL3SMP_E/005\")\\\n                    .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\\\n                    .select('soil_moisture_am')\n    mean_soil_moisture = smap_dataset.mean().rename('SMS_AM')\n    # Load Radiometer Global Daily 9 km Soil Moisture PM\n\n    smapDataset_pm = ee.ImageCollection(\"NASA/SMAP/SPL3SMP_E/005\")\\\n                       .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\\\n                       .select('soil_moisture_am') \n    meanSoilMoisture_pm = smapDataset_pm.mean().rename('SMS_PM')\n    \n    # Load MODIS Land Surface Temperature DAY\n    #`LST_Day_1km` & `LST_Night_1km` parameter of the dataset which provides 'Daytime Land Surface Temperature' &\n    # Nighttime Land Surface Temperature' both in Kelvin (K).\n    lstDataset = ee.ImageCollection(\"MODIS/061/MOD11A1\")\\\n                   .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\n \n    lstmean_celsius = lstDataset.select('LST_Day_1km')\\\n                                .mean()\\\n                                .multiply(0.02)\\\n                                .subtract(273.15)\\\n                                .rename('LST_DAY')\n    # Load MODIS Land Surface Temperature NIGHT\n    lstDataset_night = ee.ImageCollection(\"MODIS/061/MOD11A1\")\\\n                         .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\n \n    lstmean_celsius_night = lstDataset_night.select('LST_Night_1km')\\\n                                              .mean()\\\n                                              .multiply(0.02)\\\n                                              .subtract(273.15)\\\n                                              .rename('LST_NIGHT')\n                         \n    # Photosynthetically Active Radiation Daily 3-Hour \n    #`GMT_1200_PAR` parameter of the dataset which provides 'Total PAR at GMT 12:00'. PAR is incident solar radiation in\n    # the visible spectrum (400-700 nanometers) and is an important variable in land-surface models having use in agriculture &\n    # other scientific applications.\n    par_12 = ee.ImageCollection(\"MODIS/061/MCD18C2\")\\\n               .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\\\n               .select('GMT_1200_PAR')\n                        \n    mean_par_12 = par_12.mean().rename('PAR'); # Calculate the Photosynthetically Active Radiation at 12\n\n                         \n    # Net Evapotranspiration\n    # `ET` parameter of the dataset which provides 'Total evapotranspiration' in kg/m^2/8day.s.\n    netevapo = ee.ImageCollection(\"MODIS/061/MOD16A2GF\")\\\n                 .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\\\n                 .select('ET')\n                    \n    mean_netevapo = netevapo.mean().rename('ET')  # Calculate the mean Soil Moisture\n\n\n    # Combine all layers\n    combinedDataset = cornNDVI.addBands(mean_precipitation).addBands(mean_s1_vv).addBands(mean_soil_moisture).addBands(lstmean_celsius).addBands(meanSoilMoisture_pm).addBands(lstmean_celsius_night).addBands(mean_par_12).addBands(mean_netevapo)\n\n    # Reduce regions and calculate mean values over the specified areas\n    combined_mean = combinedDataset.reduceRegions(\n        collection=nd,\n        reducer=ee.Reducer.mean(),\n        scale=30,\n        tileScale=4,\n    )\n\n    # Define export parameters\n    export_params = {\n        'collection': combined_mean,\n        'description': f'combined_{year}',\n        'folder': 'GEE_Folder',\n        'fileNamePrefix': f'Combined_{year}',\n        'fileFormat': 'CSV',\n        'selectors': ['NAME', 'GEOID', 'NDVI', 'PA', 'SAR', 'SMS_AM', 'LST_DAY', 'SMS_PM', 'LST_NIGHT', 'PAR', 'ET']\n    }\n\n    # Commented the line below as I have got the data in my drive already\n    #ee.batch.Export.table.toDrive(**export_params).start()\n\n# Example of processing each year\nfor year in range(2000, 2024):\n    processYear(year)\n- This part need to be filled\n\n\n\nMethodolog\n\nThe Interface Code is as follows : y```js\n\n\n```js\n\n// ——————————————————————————define crop layers———————————————————————————————\n\nvar cropLayers = {\n  Corn: {\n    // Add layers of corn\n    '2018': ee.Image(\"projects/ee-songzimeng/assets/corn2018\"),\n    '2019': ee.Image(\"projects/ee-songzimeng/assets/corn2019\"),\n    '2020': ee.Image(\"projects/ee-songzimeng/assets/corn2020\"),\n    '2021': ee.Image(\"projects/ee-songzimeng/assets/corn2021\"),\n    '2022': ee.Image(\"projects/ee-songzimeng/assets/corn2022\"),\n    '2023': ee.Image(\"projects/ee-songzimeng/assets/corn2023\"),\n    '2024': ee.Image(\"projects/ee-songzimeng/assets/corn2024\")\n    \n  },\n  \n  Soybean: {\n    // Add layers of soybean\n\n    '2018': ee.Image(\"projects/ee-songzimeng/assets/soybean2018\"),\n    '2019': ee.Image(\"projects/ee-songzimeng/assets/soybean2019\"),\n    '2020': ee.Image(\"projects/ee-songzimeng/assets/soybean2020\"),\n    '2021': ee.Image(\"projects/ee-songzimeng/assets/soybean2021\"),\n    '2022': ee.Image(\"projects/ee-songzimeng/assets/soybean2022\"),\n    '2023': ee.Image(\"projects/ee-songzimeng/assets/soybean2023\"),\n    '2024': ee.Image(\"projects/ee-songzimeng/assets/soybean2024\")\n  },\n  \n  Wheat: {\n    // Add layers of wheat\n\n    '2018': ee.Image(\"projects/ee-songzimeng/assets/wheat2018\"),\n    '2019': ee.Image(\"projects/ee-songzimeng/assets/wheat2019\"),\n    '2020': ee.Image(\"projects/ee-songzimeng/assets/wheat2020\"),\n    '2021': ee.Image(\"projects/ee-songzimeng/assets/wheat2021\"),\n    '2022': ee.Image(\"projects/ee-songzimeng/assets/wheat2022\"),\n    '2023': ee.Image(\"projects/ee-songzimeng/assets/wheat2023\"),\n    '2024': ee.Image(\"projects/ee-songzimeng/assets/wheat2024\")\n  }\n};\n\n// -------------------------- Data  ------------------------------\nMap.setCenter(-100.55, 47.5, 7);\nMap.setOptions('SATELLITE');\n\n// clip the north dakota\nvar counties = ee.FeatureCollection('TIGER/2016/Counties');\nvar nd = counties.filter(ee.Filter.eq('STATEFP', '38'));\n\n// Formatted county name function\nvar nd = nd.map(function(feature) {\n  var name = ee.String(feature.get('NAME')).toUpperCase().replace(' ', '', 'g');\n  return feature.set('NAME', name);\n});\n\n// Show the county boundary\nvar ndCounties = ee.Image().byte().paint({\n  featureCollection: nd,\n  color: null, \n  width: 1\n});\n\n// Add the counties layer\nMap.addLayer(ndCounties, {}, 'ND Counties');\n\n/// ——————————————Function and global variables——————————————————————————\n// Function to read csv\nfunction readCsvFile(selectedYear, selectedCrop) {\n  var fileName = selectedYear +'_'+ selectedCrop;\n  var csvFile = ee.FeatureCollection('projects/ee-songzimeng/assets/' + fileName); \n\n  return csvFile;\n}\n\n// Function to fomat county name\nfunction processCountyColumn(table) {\n  var countyColumnName = 'County';\n  function processCountyName(countyName) {\n    return ee.String(countyName).toUpperCase().replace('\\\\s+', '');\n  }\n  \n  var processedCountyColumn = table.map(function(feature) {\n    var countyName = feature.get(countyColumnName);\n    var processedCountyName = processCountyName(countyName);\n    return feature.set(countyColumnName, processedCountyName);\n  });\n  \n  // return FeatureCollection\n  return processedCountyColumn;\n}\n\nvar selectedCrop='Select...';\nvar selectedYear='Select...';\nvar soybeanPrice = 11.90; // 2024 average\nvar CornPrice = 41.68; // 2024 average\nvar wheatPrice = 6.07; // 2024 average\nvar cropPrice = 0; //\n\nvar crops = {\n  'Corn': 1,\n  'Wheat': 23,\n  'Soybean': 5\n};\n\n\n// ————————————————interface——————————————————————————\n// set default year\nvar defaultYear = '2018';\n\nvar cropYieldLayer = null;\n\nvar statsLabel_1 = ui.Label('Click on County to see info:');\nvar statsLabel_2 = ui.Label('Select an area to see info:');\n\n// set original info status\nstatsLabel_1.style().set('shown', true);\nstatsLabel_2.style().set('shown', false);\n\n// Clear button to remove all selected layers\nvar drawingTools = Map.drawingTools();\nvar clearButton = ui.Button({\n  label: 'Clear Selected Area',\n  onClick: function() {\n\n    var layers = drawingTools.layers();\n\n    layers.forEach(function(layer) {\n      drawingTools.layers().remove(layer);\n    });\n\n    resultsPanel.clear();\n  },\n  style: {margin: '10px'}\n});\n\n\n// the main panel to select mode, year, croptype\nvar panel = ui.Panel({\n  widgets: [\n    \n    ui.Label('North Dakota Crop Yield', {\n      fontWeight: 'bold',\n      fontSize: '22px',\n      textAlign: 'center',\n      stretch: 'horizontal'\n      \n    }),\n    \n    ui.Label('Select Mode:'),\n    ui.Select({\n      items: ['Select...','County Level', 'Area Level'],\n      value: 'Select...',\n      onChange: function(mode) {\n        \n        // operate different \n        if (mode === 'County Level') {\n          // County Level\n          statsLabel_1.style().set('shown', true);\n          statsLabel_2.style().set('shown', false);\n          \n          // reset button\n          panel.remove(clearButton);\n          panel.add(clearButton);\n          \n          // ban polygon drawing selection\n          var drawingTools = Map.drawingTools();\n          drawingTools.setShown(false);\n          \n          //Function for getting value from image\n          var getCalculation = function(countyName, cropYieldLayer) {\n            var county = nd.filter(ee.Filter.eq('NAME', countyName)).first();\n            var countyGeometry = county.geometry();\n            \n             //print(selectedYear, selectedCrop);\n            var countyData=readCsvFile(selectedYear, selectedCrop);\n            // print(countyData);\n            countyData = processCountyColumn(countyData);\n            \n            resultsPanel.clear();\n          \n            var countStats = cropYieldLayer.reduceRegion({\n              reducer: ee.Reducer.count(),\n              geometry: countyGeometry,\n              scale: 30,\n              maxPixels: 1e9\n            });\n           //print(countStats);\n          \n            var selectedCounty = countyData.filter(ee.Filter.eq('County', countyName));\n            var averYield = selectedCounty.reduceColumns({\n            reducer: ee.Reducer.mean(),\n            selectors: ['Value']\n          });\n            //print(averYield);\n          \n            // create labels\n            var countyLabel = ui.Label({\n              value: 'County: ' + countyName,\n              style: {fontSize: '13px', padding: '0px 50px'}\n            });\n          \n            var count_sumLabel = ui.Label({\n              value: 'Calculating...',\n              style: {fontSize: '13px', padding: '0px 50px'}\n            });\n          \n          // update labels by calculating\n          // get the mean yield data\n            averYield.evaluate(function(result) {\n              var meanYield = result.mean;\n              var count_averYieldLabel = ui.Label({\n                value: 'Average Yield: ' + meanYield.toFixed(2) + ' BU/Acre', \n                style: {fontSize: '13px', padding: '0px 50px'}\n              });\n                resultsPanel.add(count_averYieldLabel);\n          });\n          \n            // calculate the area and total yield\n            countStats.get('YIELDpredicted').evaluate(function(value){\n\n              var areaInSqKm = (value / 1e6) * 900;\n              var areaInAcres = areaInSqKm * 247.105;\n              count_sumLabel.setValue('Crop Area: ' + areaInSqKm.toFixed(2) + \n                                      ' km² (' + areaInAcres.toFixed(2) + ' Acres)');\n                                      \n              averYield.evaluate(function(result) {\n                var meanYield = result.mean;\n                var totalYield = areaInAcres * meanYield;\n                var count_totalYieldLabel = ui.Label({\n                  value: 'Total Yield: ' + totalYield.toFixed(2) + ' BU', \n                  style: {fontSize: '13px', padding: '0px 50px'}\n                });\n                var yieldPrice = totalYield * cropPrice;\n                var yieldPriceLabel = ui.Label({\n                  value: 'Total Yield Value: ' + yieldPrice.toFixed(2) + ' $', \n                  style: {fontSize: '13px', padding: '0px 50px'}\n                });\n                resultsPanel.add(count_totalYieldLabel);\n                resultsPanel.add(yieldPriceLabel);\n          });\n            });\n          \n            // add the new label to sub-panel\n            resultsPanel.add(countyLabel);\n            resultsPanel.add(count_sumLabel);\n          };\n          \n          Map.unlisten()\n          \n            // create onclick function\n          Map.onClick(function(coords) {\n            \n          var point = ee.Geometry.Point(coords.lon, coords.lat);\n          var county = ee.Feature(nd.filterBounds(point).first());\n          var countyName = county.get('NAME');\n          countyName.evaluate(function(name) {\n            getCalculation(name, cropYieldLayer);\n          });\n          })\n          \n\n          // Area level\n        } else if (mode === 'Area Level') {\n\n          statsLabel_1.style().set('shown', false);\n          statsLabel_2.style().set('shown', true);\n          \n          // delet onclick monitor\n          Map.unlisten()\n          \n          //reset button\n          panel.remove(clearButton);\n          panel.add(clearButton);\n          \n          // draw polygon\n          var drawingTools = Map.drawingTools();\n          drawingTools.setShown(true);\n    \n    \n          // function under area level\n          function initializeAreaLevelMode() {\n            // create a new drawing tools\n            var drawingTools = Map.drawingTools();\n            drawingTools.setShown(true);\n            \n            drawingTools.onDraw(function(geometry) {\n              // get the polygon user drawing\n              var userPolygon = geometry;\n              \n              // calculate pixels number inside the polygon user draw\n              var pixelCount = cropYieldLayer.reduceRegion({\n                reducer: ee.Reducer.count(),\n                geometry: userPolygon,\n                scale: 30,\n                maxPixels: 1e9\n              });\n              \n              //calculate average yield user draw\n             var meanStats = cropYieldLayer.reduceRegion({\n              reducer: ee.Reducer.mean(),\n              geometry: userPolygon,\n              scale: 30,\n              maxPixels: 1e9\n            });\n              // print(meanStats)\n\n                // combined 2 results\n              var results = ee.Dictionary({\n                  meanYield: meanStats.get('YIELDpredicted'),\n                  pixelCount: pixelCount.get('YIELDpredicted')\n              });\n\n              // calculate average yield, crop area, total yield, and update labels\n              results.evaluate(function(values)  {\n                resultsPanel.clear();\n                \n              var area_sumLabel = ui.Label({\n                value: 'Calculating...',\n                style: {fontSize: '14px', padding: '0px 50px'}\n              });\n              \n              var meanYield_sumLabel = ui.Label({\n                value: 'Calculating...',\n                style:{fontSize: '14px', padding: '0px 50px'}\n              });\n              \n              var count_totalYieldLabel = ui.Label({\n                value: 'Calculating...',\n                style:{fontSize: '14px', padding: '0px 50px'}\n              });\n          \n              resultsPanel.add(area_sumLabel);\n              resultsPanel.add(meanYield_sumLabel);\n              resultsPanel.add(count_totalYieldLabel);\n          \n              meanYield_sumLabel.setValue('Average Yield: ' + values.meanYield.toFixed(2) + ' BU/Acre');\n          \n              var areaInSqKm = (values.pixelCount / 1e6) * 900;\n              var areaInAcres = areaInSqKm * 247.105;\n              area_sumLabel.setValue('Crop Area: ' + areaInSqKm.toFixed(2) + \n                                      ' km² (' + areaInAcres.toFixed(2) + ' Acres)');\n                                      \n              var totalYield = areaInAcres * values.meanYield;\n              count_totalYieldLabel.setValue('Total Yield: ' + totalYield.toFixed(2) + ' BU'); \n               \n              var yieldPrice = totalYield * cropPrice;\n              var yieldPriceLabel = ui.Label({\n                  value: 'Total Yield Value: ' + yieldPrice.toFixed(2) + ' $', \n                  style: {fontSize: '13px', padding: '0px 50px'}\n                });\n              resultsPanel.add(yieldPriceLabel);\n                \n                });\n                \n            });\n\n          }\n          initializeAreaLevelMode();\n          \n        }\n        \n      }\n    }),\n    \n    ui.Label('Select Year:'),\n    ui.Select({\n      items: ['Select...', '2018', '2019', '2020', \n                 '2021', '2022', '2023', '2024'],\n      value: 'Select...',\n      onChange: function(year) {\n        \n        // update global variable selectedYear, the year user chose\n        selectedYear = year;\n        updateMap();\n\n      }\n    }),\n    \n    ui.Label('Select Crop:'),\n    ui.Select({\n      items: ['Select...', 'Soybean', 'Corn', 'Wheat'],\n      value: 'Select...',\n      onChange: function(crop) {\n        \n        selectedCrop = crop;\n        \n        // set cropPrice according to selected \n        if (selectedCrop === 'Soybean') {\n          cropPrice = 11.90; \n        } else if (selectedCrop === 'Wheat') {\n          cropPrice = 6.07; \n        } else if (selectedCrop === 'Corn') {\n          cropPrice = 5.80; \n        } else {\n          cropPrice = 0;\n        }\n        \n        updateMap();\n        \n      }\n    }),\n    \n    statsLabel_1,\n    statsLabel_2\n  ],\n  style: {position: 'top-right'}\n});\n\nMap.add(panel);\n\n// Add a sub-panel to show calculation info\nvar resultsPanel = ui.Panel({\n  layout: ui.Panel.Layout.Flow('vertical'),\n  style: {width: '310px'} \n});\npanel.add(resultsPanel);\n\n// update new layers accoording to user's selection\nfunction updateMap() {\n\n  // // Remove particular layers\n  // Map.layers().forEach(function(layer) {\n  //   var layerName = layer.getName();\n  //   if (layerName.indexOf('YIELD_') === 0) {\n  //     Map.remove(layer);\n  //   }\n  // });\n  \n  Maay\n```.reset();\n\n  // Show layers if user choose both selections\n  if (selectedYear !== 'Select...' && selectedCrop !== 'Select...') {\n    \n      cropYieldLayer = cropLayers[selectedCrop][selectedYear];\n\n    if (cropYieldLayer) {\n      var layerName = selectedCrop + '_' + selectedYear;\n      Map.addLayer(cropYieldLayer, {}, 'YIELD_' + layerName);\n    }\n\n  }\n  \n  // add the counties layer\n  Map.addLayer(ndCounties, {}, 'ND Counties');\n  \n}\n\n```:\n\n### Interface Code:\n\n![](Captnknure.JPG)\n\n## **Project Summary**\n\nCROPINVEST - Crop Yield Estimator for the State of North Dakota, USA\n\n## **Problem Statement**\n\nWhat is the problem you’re trying to address using this application? \n\n## **End User**\n\nWho are you building this application for? How does it address a need this community has?\n\n## **Data**\n\nDatasets that we have used & the relevant data from the dataset which we have used are described below in detail:-\n\n1. **United States Census Bureau TIGER Dataset**\n   It contains the boundary information i.e. counties of states which are the primary legal divisions units of US states.\n    - *Dataset:* ee.ImageCollection(\"TIGER/2016/Counties\")\n    - *Dataset Provider:* United States Census Bureau\n    - *Data Used for our Study:* `STATEFP` parameter of the dataset which provides the State FIPS code & the North Dakota value is used.\n&lt;br&gt;&lt;br&gt;     \n2. **USDA NASS Cropland Data Layers**\n   It is a crop-specific land cover data layer created annually for the continental United States using moderate resolution satellite imagery and extensive agricultural ground truth.\n    - *Dataset:* ee.FeatureCollection(\"USDA/NASS/CDL\")\n    - *Dataset Provider:* USDA National Agricultural Statistics Service\n    - *Data Used for our Study:* `cropland` values for different crops of our study are used Wheat, Corn & Soybean Values provided from the Cropland Table.\n&lt;br&gt;&lt;br&gt;     \n3. **MOD13Q1.061 Terra Vegetation Indices 16-Day Global**\n   It provides Normalized Difference Vegetation Index (NDVI) value on a per pixel basis. \n    - *Dataset:* ee.ImageCollection(\"MODIS/061/MOD13Q1\")\n    - *Dataset Provider:* NASA LP DAAC at the USGS EROS Center\n    - *Data Used for our Study:* `NDVI` parameter of the dataset which provides the Normalized Difference Vegetation Index.\n&lt;br&gt;&lt;br&gt;     \n4. **GRIDMET:Gridded Surface Meteorological Dataset**\n   It provides the high spatial resolution (~4-km) daily surface fields of temperature, precipitation, winds, humidity and radiation across the contiguous United States from 1979. \n    - *Dataset:* ee.ImageCollection(\"IDAHO_EPSCOR/GRIDMET\")\n    - *Dataset Provider:* USDA National Agricultural Statistics Service\n    - *Data Used for our Study:* `pr` parameter of the dataset which provides the 'Precipitation amount' in mm (daily total)\n&lt;br&gt;&lt;br&gt;      \n5. **Sentinel-1 SAR GRD**\n   It contains the boundary information i.e. counties of states which are the primary legal divisions units of US states.\n    - *Dataset:* ee.ImageCollection(\"COPERNICUS/S1_GRD\")\n    - *Dataset Provider:* European Union/ESA/Copernicus\n    - *Data Used for our Study:* `VV` parameter of the dataset which provides 'Single co-polarization, vertical transmit/vertical receive' in dB.\n&lt;br&gt;&lt;br&gt; \n6. **SPL3SMP_E.005 SMAP L3 Radiometer Global Daily 9km Soil Moisture**\n   It provides a daily composite of global land surface conditions retrieved by the Soil Moisture Active Passive (SMAP) L-Band radiometer. The daily data here were collected from the descending (local solar time of 6 am) and ascending (local solar time of 6 pm) passes.\n    - *Dataset:* ee.ImageCollection(\"NASA/SMAP/SPL3SMP_E/005\")\n    - *Dataset Provider:* Google and NSIDC\n    - *Data Used for our Study:* `soil_moisture_am` & `soil_moisture_pm`parameter of the dataset which provides 'Retrieved soil moisture estimate from the disaggregated/downscaled vertical polarization brightness temperature at 9-km grid cell one at AM overpass & other at  PM overpass.in dB.\n&lt;br&gt;&lt;br&gt;\n7. **MOD11A1.061 Terra Land Surface Temperature**\n   MOD11A1 V6.1 product provides daily land surface temperature (LST) along with other parameters.\n    - *Dataset:* ee.ImageCollection(\"NASA/SMAP/SPL3SMP_E/005\")\n    - *Dataset Provider:* NASA LP DAAC at the USGS EROS Center\n    - *Data Used for our Study:* `LST_Day_1km` & `LST_Night_1km`parameter of the dataset which provides 'Daytime Land Surface Temperature' & Daytime Land Surface Temperature' both in Kelvin (K).\n&lt;br&gt;&lt;br&gt;\n8. **MCD18C2.061 Photosynthetically Active Radiation Daily 3 hour**\n   The MCD18C2 Version 6.1 is a Moderate Resolution Imaging Spectroradiometer (MODIS) Terra and Aqua combined Photosynthetically Active Radiation (PAR) gridded Level 3 product produced daily at 0.05 degree (5,600 meters at the equator) resolution with estimates of PAR every 3 hours. \n    - *Dataset:* ee.ImageCollection(\"MODIS/061/MCD18C2\")\n    - *Dataset Provider:* NASA LP DAAC at the USGS EROS Center\n    - *Data Used for our Study:* `GMT_1200_PAR` parameter of the dataset which provides 'Total PAR at GMT 12:00'.PAR is incident solar radiation in the visible spectrum (400-700 nanometers) and is an important variable in land-surface models having use in agriculture & other scientific applications.\n&lt;br&gt;&lt;br&gt;\n9. **MOD16A2GF.061: Terra Net Evapotranspiration**\n   It includes inputs of daily meteorological reanalysis data along with MODIS remotely sensed data products such as vegetation property dynamics, albedo, and land cover.\nThe pixel values for the two Evapotranspiration layers (ET and PET) are the sum of all eight days within the composite period, and the pixel values for the two Latent Heat layers (LE and PLE) are the average of all eight days within the composite peri.\n   - *Dataset:* ee.ImageCollection(\"MODIS/061/MOD16A2GF\")\n   - *Dataset Provider:* NASA LP DAAC at the USGS EROS Center\n   - *Data Used for our Study:* `ET` parameter of the dataset which provides 'Total evapotranspiration' in kg/m^2/8day.s.\n&lt;br&gt;&lt;br&gt;\n\n## **Methodology**\n\nPrevious studies showed that RF is an effective and universal machine learning method for crop yield prediction on a regional and global scale with high accuracy and precision and ease of use (Jeong et al., 2016.; Prasad et al., 2021).\n\n### Building Random Forest Model:\n\n1. **Prepare original CSV including the three types of crop among several X variables and Y variable (the crop yield)**\n   \n2. **Prepare training/validation data**    \n\n3. **Use the training data to train three different RF Models in GEE**\n\n### Validation\n\nTo get the performance of our models, we can use the test data from the previous split. We used R square and Root Mean Squared Error (RMSE) to validate our models. There are some graphs showing these metrics: \n\n:::{.column-page}\n\n&lt;div style=\"position: relative; width: 100%; height: 0; padding-top: 56.2500%;\n padding-bottom: 0; box-shadow: 0 2px 8px 0 rgba(63,69,81,0.16); margin-top: 1.6em; margin-bottom: 0.9em; overflow: hidden;\n border-radius: 8px; will-change: transform;\"&gt;\n  &lt;iframe loading=\"lazy\" style=\"position: absolute; width: 100%; height: 100%; top: 0; left: 0; border: none; padding: 0;margin: 0;\"\n    src=\"https:&#x2F;&#x2F;www.canva.com&#x2F;design&#x2F;DAGC-BnkFTM&#x2F;htfGBGmKgWUiwQRlwaqXgQ&#x2F;view?embed\" allowfullscreen=\"allowfullscreen\" allow=\"fullscreen\"&gt;\n  &lt;/iframe&gt;\n&lt;/div&gt;\n\n:::\n\n## **Interface**\n\nHere is a presentation to show, how our application work:\n\n&lt;div style=\"position: relative; width: 100%; height: 0; padding-top: 56.2500%;\n padding-bottom: 0; box-shadow: 0 2px 8px 0 rgba(63,69,81,0.16); margin-top: 1.6em; margin-bottom: 0.9em; overflow: hidden;\n border-radius: 8px; will-change: transform;\"&gt;\n  &lt;iframe loading=\"lazy\" style=\"position: absolute; width: 100%; height: 100%; top: 0; left: 0; border: none; padding: 0;margin: 0;\"\n    src=\"https:&#x2F;&#x2F;www.canva.com&#x2F;design&#x2F;DAGCq_eFmq8&#x2F;Muz__V20V7SJUNr3EVBSEQ&#x2F;view?embed\" allowfullscreen=\"allowfullscreen\" allow=\"fullscreen\"&gt;\n  &lt;/iframe&gt;\n&lt;/div&gt;\n&lt;a href=\"https:&#x2F;&#x2F;www.canva.com&#x2F;design&#x2F;DAGCq_eFmq8&#x2F;Muz__V20V7SJUNr3EVBSEQ&#x2F;view?utm_content=DAGCq_eFmq8&amp;utm_campaign=designshare&amp;utm_medium=embeds&amp;utm_source=link\" target=\"_blank\" rel=\"noopener\"&gt;CropInvest-Burhan&lt;/a&gt;\n\n\n## **The Application**\n\n:::{.column-page}\n\n&lt;iframe src='https://songzimeng.users.earthengine.app/view/north-dakota-crop-yield' width='100%' height='700px'&gt;&lt;/iframe&gt;\n\n:::\n\n## **How it Works**\n\n### Data Extraction Code:\n- Here we use the Python environment to extract the data from different datasets using Google Earth Engine API\n- Afterwards, we first use the crop-specific land cover data to distinguish different crops- wheat, soybean or corn for each county in North Dakota.\n- Further, NDVI, Precipitation, SAR, Soil Moisture & other values are used to get the county-wise values from the year 2000-2024.\n- Afterwards, the Yield data is obtained from the [United States Department of Agriculture](https://quickstats.nass.usda.gov/) for each of the years and a final dataset is obtained which has all the X Variables (GEOID,NDVI,PA,SAR,SMS_AM,LST_DAY,SMS_PM,LST_NIGHT,PAR,ET) & Y variable (YIELD).\n\n```python\n\npip install earthengine-api\nimport ee\nee.AuthcessYear(year):\n    # Load the CDL dataset for the given year\n    dataset = ee.ImageCollection('USDA/NASS/CDL')\\\n                .filter(ee.Filter.date(f'{year}-01-01', f'{year}-12-31'))\\\n                .first()\n    crop_landcover = dataset.select('cropland')\n\n    # Filter for North Dakota counties\n    #`STATEFP` parameter of the dataset which provides the State FIPS code & the North Dakota value is used.\n    counties = ee.FeatureCollection('TIGER/2016/Counties')\n    nd = counties.filter(ee.Filter.eq('STATEFP', '38'))\n    \n    # Identify corn areas in North Dakota\n    #`cropland` values for different crops of our study are used Wheat, Corn & Soybean Values provided from the Cropland Table.\n    corn = crop_landcover.eq(1).Or(crop_landcover.eq(12)).Or(crop_landcover.eq(13))\n    masked_corn = crop_landcover.updateMask(corn).clipToCollection(nd)\n\n    # Calculate NDVI for corn areas using MODIS data\n    #`NDVI` parameter of the dataset and we obtain the mean over the growth period of the crop\n    NDVI_dataset = ee.ImageCollection('MODIS/061/MOD13Q1')\\\n                    .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\n    ndvi = NDVI_dataset.select('NDVI')\n    mean_ndvi = ndvi.mean().rename('NDVI')\n    cornNDVI = mean_ndvi.updateMask(masked_corn)\n    \n    # Calculate precipitation using GRIDMET data\n    #`pr` parameter of the dataset which provides the 'Precipitation amount' in mm (daily total)\n    precipitation_dataset = ee.ImageCollection(\"IDAHO_EPSCOR/GRIDMET\")\\\n                             .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\\\n                             .select('pr')\n    mean_precipitation = precipitation_dataset.mean().rename('PA')\n\n    # Load Sentinel-1 C-band SAR Image Collection for the given year, select VV polarization\n    #`VV` parameter of the dataset which provides 'Single co-polarization, vertical transmit/vertical receive' in dB.\n    s1_dataset = ee.ImageCollection(\"COPERNICUS/S1_GRD\")\\\n                   .filter(ee.Filter.eq('instrumentMode', 'IW'))\\\n                   .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))\\\n                   .filter(ee.Filter.date(f'{year}-01-01', f'{year}-12-31'))\\\n                   .select('VV')\n    mean_s1_vv = s1_dataset.mean().rename('SAR')\n\n    # Load Radiometer Global Daily 9 km Soil Moisture AM\n    #`soil_moisture_am` & `soil_moisture_pm` parameter of the dataset which provides 'Retrieved soil moisture estimate from the\n    # disaggregated/downscaled vertical polarization brightness temperature at 9-km grid cell one at AM overpass & other at  PM overpass. in dB.\n    smap_dataset = ee.ImageCollection(\"NASA/SMAP/SPL3SMP_E/005\")\\\n                    .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\\\n                    .select('soil_moisture_am')\n    mean_soil_moisture = smap_dataset.mean().rename('SMS_AM')\n    # Load Radiometer Global Daily 9 km Soil Moisture PM\n\n    smapDataset_pm = ee.ImageCollection(\"NASA/SMAP/SPL3SMP_E/005\")\\\n                       .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\\\n                       .select('soil_moisture_am') \n    meanSoilMoisture_pm = smapDataset_pm.mean().rename('SMS_PM')\n    \n    # Load MODIS Land Surface Temperature DAY\n    #`LST_Day_1km` & `LST_Night_1km` parameter of the dataset which provides 'Daytime Land Surface Temperature' &\n    # Nighttime Land Surface Temperature' both in Kelvin (K).\n    lstDataset = ee.ImageCollection(\"MODIS/061/MOD11A1\")\\\n                   .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\n \n    lstmean_celsius = lstDataset.select('LST_Day_1km')\\\n                                .mean()\\\n                                .multiply(0.02)\\\n                                .subtract(273.15)\\\n                                .rename('LST_DAY')\n    # Load MODIS Land Surface Temperature NIGHT\n    lstDataset_night = ee.ImageCollection(\"MODIS/061/MOD11A1\")\\\n                         .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\n \n    lstmean_celsius_night = lstDataset_night.select('LST_Night_1km')\\\n                                              .mean()\\\n                                              .multiply(0.02)\\\n                                              .subtract(273.15)\\\n                                              .rename('LST_NIGHT')\n                         \n    # Photosynthetically Active Radiation Daily 3-Hour \n    #`GMT_1200_PAR` parameter of the dataset which provides 'Total PAR at GMT 12:00'. PAR is incident solar radiation in\n    # the visible spectrum (400-700 nanometers) and is an important variable in land-surface models having use in agriculture &\n    # other scientific applications.\n    par_12 = ee.ImageCollection(\"MODIS/061/MCD18C2\")\\\n               .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\\\n               .select('GMT_1200_PAR')\n                        \n    mean_par_12 = par_12.mean().rename('PAR'); # Calculate the Photosynthetically Active Radiation at 12\n\n                         \n    # Net Evapotranspiration\n    # `ET` parameter of the dataset which provides 'Total evapotranspiration' in kg/m^2/8day.s.\n    netevapo = ee.ImageCollection(\"MODIS/061/MOD16A2GF\")\\\n                 .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\\\n                 .select('ET')\n                    \n    mean_netevapo = netevapo.mean().rename('ET')  # Calculate the mean Soil Moisture\n\n\n    # Combine all layers\n    combinedDataset = cornNDVI.addBands(mean_precipitation).addBands(mean_s1_vv).addBands(mean_soil_moisture).addBands(lstmean_celsius).addBands(meanSoilMoisture_pm).addBands(lstmean_celsius_night).addBands(mean_par_12).addBands(mean_netevapo)\n\n    # Reduce regions and calculate mean values over the specified areas\n    combined_mean = combinedDataset.reduceRegions(\n        collection=nd,\n        reducer=ee.Reducer.mean(),\n        scale=30,\n        tileScale=4,\n    )\n\n    # Define export parameters\n    export_params = {\n        'collection': combined_mean,\n        'description': f'combined_{year}',\n        'folder': 'GEE_Folder',\n        'fileNamePrefix': f'Combined_{year}',\n        'fileFormat': 'CSV',\n        'selectors': ['NAME', 'GEOID', 'NDVI', 'PA', 'SAR', 'SMS_AM', 'LST_DAY', 'SMS_PM', 'LST_NIGHT', 'PAR', 'ET']\n    }\n\n    # Commented the line below as I have got the data in my drive already\n    #ee.batch.Export.table.toDrive(**export_params).start()\n\n# Example of processing each year\nfor year in range(2000, 2024):\n    processYear(year)\n\n\n\nMethodology Code:\n\nThis part need to be filled\n\n\n\nInterface Code:\n\nThe Interface Code is as follows :\n\n// ——————————————————————————define crop layers————————————————————————————————\nvar cropLayers = {\n  Corn: {\n    // Add layers of corn\n    '2018': ee.Image(\"projects/ee-songzimeng/assets/corn2018\"),\n    '2019': ee.Image(\"projects/ee-songzimeng/assets/corn2019\"),\n    '2020': ee.Image(\"projects/ee-songzimeng/assets/corn2020\"),\n    '2021': ee.Image(\"projects/ee-songzimeng/assets/corn2021\"),\n    '2022': ee.Image(\"projects/ee-songzimeng/assets/corn2022\"),\n    '2023': ee.Image(\"projects/ee-songzimeng/assets/corn2023\"),\n    '2024': ee.Image(\"projects/ee-songzimeng/assets/corn2024\")\n    \n  },\n  \n  Soybean: {\n    // Add layers of soybean\n\n    '2018': ee.Image(\"projects/ee-songzimeng/assets/soybean2018\"),\n    '2019': ee.Image(\"projects/ee-songzimeng/assets/soybean2019\"),\n    '2020': ee.Image(\"projects/ee-songzimeng/assets/soybean2020\"),\n    '2021': ee.Image(\"projects/ee-songzimeng/assets/soybean2021\"),\n    '2022': ee.Image(\"projects/ee-songzimeng/assets/soybean2022\"),\n    '2023': ee.Image(\"projects/ee-songzimeng/assets/soybean2023\"),\n    '2024': ee.Image(\"projects/ee-songzimeng/assets/soybean2024\")\n  },\n  \n  Wheat: {\n    // Add layers of wheat\n\n    '2018': ee.Image(\"projects/ee-songzimeng/assets/wheat2018\"),\n    '2019': ee.Image(\"projects/ee-songzimeng/assets/wheat2019\"),\n    '2020': ee.Image(\"projects/ee-songzimeng/assets/wheat2020\"),\n    '2021': ee.Image(\"projects/ee-songzimeng/assets/wheat2021\"),\n    '2022': ee.Image(\"projects/ee-songzimeng/assets/wheat2022\"),\n    '2023': ee.Image(\"projects/ee-songzimeng/assets/wheat2023\"),\n    '2024': ee.Image(\"projects/ee-songzimeng/assets/wheat2024\")\n  }\n};\n\n// -------------------------- Data  ------------------------------\nMap.setCenter(-100.55, 47.5, 7);\nMap.setOptions('SATELLITE');\n\n// clip the north dakota\nvar counties = ee.FeatureCollection('TIGER/2016/Counties');\nvar nd = counties.filter(ee.Filter.eq('STATEFP', '38'));\n\n// Formatted county name function\nvar nd = nd.map(function(feature) {\n  var name = ee.String(feature.get('NAME')).toUpperCase().replace(' ', '', 'g');\n  return feature.set('NAME', name);\n});\n\n// Show the county boundary\nvar ndCounties = ee.Image().byte().paint({\n  featureCollection: nd,\n  color: null, \n  width: 1\n});\n\n// Add the counties layer\nMap.addLayer(ndCounties, {}, 'ND Counties');\n\n/// ——————————————Function and global variables——————————————————————————\n// Function to read csv\nfunction readCsvFile(selectedYear, selectedCrop) {\n  var fileName = selectedYear +'_'+ selectedCrop;\n  var csvFile = ee.FeatureCollection('projects/ee-songzimeng/assets/' + fileName); \n\n  return csvFile;\n}\n\n// Function to fomat county name\nfunction processCountyColumn(table) {\n  var countyColumnName = 'County';\n  function processCountyName(countyName) {\n    return ee.String(countyName).toUpperCase().replace('\\\\s+', '');\n  }\n  \n  var processedCountyColumn = table.map(function(feature) {\n    var countyName = feature.get(countyColumnName);\n    var processedCountyName = processCountyName(countyName);\n    return feature.set(countyColumnName, processedCountyName);\n  });\n  \n  // return FeatureCollection\n  return processedCountyColumn;\n}\n\nvar selectedCrop='Select...';\nvar selectedYear='Select...';\nvar soybeanPrice = 11.90; // 2024 average\nvar CornPrice = 41.68; // 2024 average\nvar wheatPrice = 6.07; // 2024 average\nvar cropPrice = 0; //\n\nvar crops = {\n  'Corn': 1,\n  'Wheat': 23,\n  'Soybean': 5\n};\n\n\n// ————————————————interface——————————————————————————\n// set default year\nvar defaultYear = '2018';\n\nvar cropYieldLayer = null;\n\nvar statsLabel_1 = ui.Label('Click on County to see info:');\nvar statsLabel_2 = ui.Label('Select an area to see info:');\n\n// set original info status\nstatsLabel_1.style().set('shown', true);\nstatsLabel_2.style().set('shown', false);\n\n// Clear button to remove all selected layers\nvar drawingTools = Map.drawingTools();\nvar clearButton = ui.Button({\n  label: 'Clear Selected Area',\n  onClick: function() {\n\n    var layers = drawingTools.layers();\n\n    layers.forEach(function(layer) {\n      drawingTools.layers().remove(layer);\n    });\n\n    resultsPanel.clear();\n  },\n  style: {margin: '10px'}\n});\n\n\n// the main panel to select mode, year, croptype\nvar panel = ui.Panel({\n  widgets: [\n    \n    ui.Label('North Dakota Crop Yield', {\n      fontWeight: 'bold',\n      fontSize: '22px',\n      textAlign: 'center',\n      stretch: 'horizontal'\n      \n    }),\n    \n    ui.Label('Select Mode:'),\n    ui.Select({\n      items: ['Select...','County Level', 'Area Level'],\n      value: 'Select...',\n      onChange: function(mode) {\n        \n        // operate different \n        if (mode === 'County Level') {\n          // County Level\n          statsLabel_1.style().set('shown', true);\n          statsLabel_2.style().set('shown', false);\n          \n          // reset button\n          panel.remove(clearButton);\n          panel.add(clearButton);\n          \n          // ban polygon drawing selection\n          var drawingTools = Map.drawingTools();\n          drawingTools.setShown(false);\n          \n          //Function for getting value from image\n          var getCalculation = function(countyName, cropYieldLayer) {\n            var county = nd.filter(ee.Filter.eq('NAME', countyName)).first();\n            var countyGeometry = county.geometry();\n            \n             //print(selectedYear, selectedCrop);\n            var countyData=readCsvFile(selectedYear, selectedCrop);\n            // print(countyData);\n            countyData = processCountyColumn(countyData);\n            \n            resultsPanel.clear();\n          \n            var countStats = cropYieldLayer.reduceRegion({\n              reducer: ee.Reducer.count(),\n              geometry: countyGeometry,\n              scale: 30,\n              maxPixels: 1e9\n            });\n           //print(countStats);\n          \n            var selectedCounty = countyData.filter(ee.Filter.eq('County', countyName));\n            var averYield = selectedCounty.reduceColumns({\n            reducer: ee.Reducer.mean(),\n            selectors: ['Value']\n          });\n            //print(averYield);\n          \n            // create labels\n            var countyLabel = ui.Label({\n              value: 'County: ' + countyName,\n              style: {fontSize: '13px', padding: '0px 50px'}\n            });\n          \n            var count_sumLabel = ui.Label({\n              value: 'Calculating...',\n              style: {fontSize: '13px', padding: '0px 50px'}\n            });\n          \n          // update labels by calculating\n          // get the mean yield data\n            averYield.evaluate(function(result) {\n              var meanYield = result.mean;\n              var count_averYieldLabel = ui.Label({\n                value: 'Average Yield: ' + meanYield.toFixed(2) + ' BU/Acre', \n                style: {fontSize: '13px', padding: '0px 50px'}\n              });\n                resultsPanel.add(count_averYieldLabel);\n          });\n          \n            // calculate the area and total yield\n            countStats.get('YIELDpredicted').evaluate(function(value){\n\n              var areaInSqKm = (value / 1e6) * 900;\n              var areaInAcres = areaInSqKm * 247.105;\n              count_sumLabel.setValue('Crop Area: ' + areaInSqKm.toFixed(2) + \n                                      ' km² (' + areaInAcres.toFixed(2) + ' Acres)');\n                                      \n              averYield.evaluate(function(result) {\n                var meanYield = result.mean;\n                var totalYield = areaInAcres * meanYield;\n                var count_totalYieldLabel = ui.Label({\n                  value: 'Total Yield: ' + totalYield.toFixed(2) + ' BU', \n                  style: {fontSize: '13px', padding: '0px 50px'}\n                });\n                var yieldPrice = totalYield * cropPrice;\n                var yieldPriceLabel = ui.Label({\n                  value: 'Total Yield Value: ' + yieldPrice.toFixed(2) + ' $', \n                  style: {fontSize: '13px', padding: '0px 50px'}\n                });\n                resultsPanel.add(count_totalYieldLabel);\n                resultsPanel.add(yieldPriceLabel);\n          });\n            });\n          \n            // add the new label to sub-panel\n            resultsPanel.add(countyLabel);\n            resultsPanel.add(count_sumLabel);\n          };\n          \n          Map.unlisten()\n          \n            // create onclick function\n          Map.onClick(function(coords) {\n            \n          var point = ee.Geometry.Point(coords.lon, coords.lat);\n          var county = ee.Feature(nd.filterBounds(point).first());\n          var countyName = county.get('NAME');\n          countyName.evaluate(function(name) {\n            getCalculation(name, cropYieldLayer);\n          });\n          })\n          \n\n          // Area level\n        } else if (mode === 'Area Level') {\n\n          statsLabel_1.style().set('shown', false);\n          statsLabel_2.style().set('shown', true);\n          \n          // delet onclick monitor\n          Map.unlisten()\n          \n          //reset button\n          panel.remove(clearButton);\n          panel.add(clearButton);\n          \n          // draw polygon\n          var drawingTools = Map.drawingTools();\n          drawingTools.setShown(true);\n    \n    \n          // function under area level\n          function initializeAreaLevelMode() {\n            // create a new drawing tools\n            var drawingTools = Map.drawingTools();\n            drawingTools.setShown(true);\n            \n            drawingTools.onDraw(function(geometry) {\n              // get the polygon user drawing\n              var userPolygon = geometry;\n              \n              // calculate pixels number inside the polygon user draw\n              var pixelCount = cropYieldLayer.reduceRegion({\n                reducer: ee.Reducer.count(),\n                geometry: userPolygon,\n                scale: 30,\n                maxPixels: 1e9\n              });\n              \n              //calculate average yield user draw\n             var meanStats = cropYieldLayer.reduceRegion({\n              reducer: ee.Reducer.mean(),\n              geometry: userPolygon,\n              scale: 30,\n              maxPixels: 1e9\n            });\n              // print(meanStats)\n\n                // combined 2 results\n              var results = ee.Dictionary({\n                  meanYield: meanStats.get('YIELDpredicted'),\n                  pixelCount: pixelCount.get('YIELDpredicted')\n              });\n\n              // calculate average yield, crop area, total yield, and update labels\n              results.evaluate(function(values)  {\n                resultsPanel.clear();\n                \n              var area_sumLabel = ui.Label({\n                value: 'Calculating...',\n                style: {fontSize: '14px', padding: '0px 50px'}\n              });\n              \n              var meanYield_sumLabel = ui.Label({\n                value: 'Calculating...',\n                style:{fontSize: '14px', padding: '0px 50px'}\n              });\n              \n              var count_totalYieldLabel = ui.Label({\n                value: 'Calculating...',\n                style:{fontSize: '14px', padding: '0px 50px'}\n              });\n          \n              resultsPanel.add(area_sumLabel);\n              resultsPanel.add(meanYield_sumLabel);\n              resultsPanel.add(count_totalYieldLabel);\n          \n              meanYield_sumLabel.setValue('Average Yield: ' + values.meanYield.toFixed(2) + ' BU/Acre');\n          \n              var areaInSqKm = (values.pixelCount / 1e6) * 900;\n              var areaInAcres = areaInSqKm * 247.105;\n              area_sumLabel.setValue('Crop Area: ' + areaInSqKm.toFixed(2) + \n                                      ' km² (' + areaInAcres.toFixed(2) + ' Acres)');\n                                      \n              var totalYield = areaInAcres * values.meanYield;\n              count_totalYieldLabel.setValue('Total Yield: ' + totalYield.toFixed(2) + ' BU'); \n               \n              var yieldPrice = totalYield * cropPrice;\n              var yieldPriceLabel = ui.Label({\n                  value: 'Total Yield Value: ' + yieldPrice.toFixed(2) + ' $', \n                  style: {fontSize: '13px', padding: '0px 50px'}\n                });\n              resultsPanel.add(yieldPriceLabel);\n                \n                });\n                \n            });\n\n          }\n          initializeAreaLevelMode();\n          \n        }\n        \n      }\n    }),\n    \n    ui.Label('Select Year:'),\n    ui.Select({\n      items: ['Select...', '2018', '2019', '2020', \n                 '2021', '2022', '2023', '2024'],\n      value: 'Select...',\n      onChange: function(year) {\n        \n        // update global variable selectedYear, the year user chose\n        selectedYear = year;\n        updateMap();\n\n      }\n    }),\n    \n    ui.Label('Select Crop:'),\n    ui.Select({\n      items: ['Select...', 'Soybean', 'Corn', 'Wheat'],\n      value: 'Select...',\n      onChange: function(crop) {\n        \n        selectedCrop = crop;\n        \n        // set cropPrice according to selected \n        if (selectedCrop === 'Soybean') {\n          cropPrice = 11.90; \n        } else if (selectedCrop === 'Wheat') {\n          cropPrice = 6.07; \n        } else if (selectedCrop === 'Corn') {\n          cropPrice = 5.80; \n        } else {\n          cropPrice = 0;\n        }\n        \n        updateMap();\n        \n      }\n    }),\n    \n    statsLabel_1,\n    statsLabel_2\n  ],\n  style: {position: 'top-right'}\n});\n\nMap.add(panel);\n\n// Add a sub-panel to show calculation info\nvar resultsPanel = ui.Panel({\n  layout: ui.Panel.Layout.Flow('vertical'),\n  style: {width: '310px'} \n});\npanel.add(resultsPanel);\n\n// update new layers accoording to user's selection\nfunction updateMap() {\n\n  // // Remove particular layers\n  // Map.layers().forEach(function(layer) {\n  //   var layerName = layer.getName();\n  //   if (layerName.indexOf('YIELD_') === 0) {\n  //     Map.remove(layer);\n  //   }\n  // });\n  \n  Map.layers().reset();\n\n  // Show layers if user choose both selections\n  if (selectedYear !== 'Select...' && selectedCrop !== 'Select...') {\n    \n      cropYieldLayer = cropLayers[selectedCrop][selectedYear];\n\n    if (cropYieldLayer) {\n      var layerName = selectedCrop + '_' + selectedYear;\n      Map.addLayer(cropYieldLayer, {}, 'YIELD_' + layerName);\n    }\n\n  }\n  \n  // add the counties layer\n  Map.addLayer(ndCounties, {}, 'ND Counties');\n}"
  }
]