<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>CROPINVEST</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="fullcontent">

<div id="quarto-search-results"></div>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">CROPINVEST</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><img src="Captnknure.JPG" class="img-fluid"></p>
<section id="project-summary" class="level2">
<h2 class="anchored" data-anchor-id="project-summary">Project Summary</h2>
<p>CROPINVEST - Crop Yield Estimator for the State of North Dakota, USA</p>
<section id="problem-statement" class="level3">
<h3 class="anchored" data-anchor-id="problem-statement">Problem Statement</h3>
<p>What is the problem you’re trying to address using this application?</p>
</section>
<section id="end-user" class="level3">
<h3 class="anchored" data-anchor-id="end-user">End User</h3>
<p>Who are you building this application for? How does it address a need this community has?</p>
</section>
<section id="data" class="level3">
<h3 class="anchored" data-anchor-id="data">Data</h3>
<p>Datasets that we have used &amp; the relevant data from the dataset which we have used are described below in detail:-</p>
<ol type="1">
<li><strong>United States Census Bureau TIGER Dataset</strong> It contains the boundary information i.e.&nbsp;counties of states which are the primary legal divisions units of US states.
<ul>
<li><em>Dataset:</em> ee.ImageCollection(“TIGER/2016/Counties”)</li>
<li><em>Dataset Provider:</em> United States Census Bureau</li>
<li><em>Data Used for our Study:</em> <code>STATEFP</code> parameter of the dataset which provides the State FIPS code &amp; the North Dakota value is used. <br><br><br>
</li>
</ul></li>
<li><strong>USDA NASS Cropland Data Layers</strong> It is a crop-specific land cover data layer created annually for the continental United States using moderate resolution satellite imagery and extensive agricultural ground truth.
<ul>
<li><em>Dataset:</em> ee.FeatureCollection(“USDA/NASS/CDL”)</li>
<li><em>Dataset Provider:</em> USDA National Agricultural Statistics Service</li>
<li><em>Data Used for our Study:</em> <code>cropland</code> values for different crops of our study are used Wheat, Corn &amp; Soybean Values provided from the Cropland Table. <br><br><br>
</li>
</ul></li>
<li><strong>MOD13Q1.061 Terra Vegetation Indices 16-Day Global</strong> It provides Normalized Difference Vegetation Index (NDVI) value on a per pixel basis.
<ul>
<li><em>Dataset:</em> ee.ImageCollection(“MODIS/061/MOD13Q1”)</li>
<li><em>Dataset Provider:</em> NASA LP DAAC at the USGS EROS Center</li>
<li><em>Data Used for our Study:</em> <code>NDVI</code> parameter of the dataset which provides the Normalized Difference Vegetation Index. <br><br><br>
</li>
</ul></li>
<li><strong>GRIDMET:Gridded Surface Meteorological Dataset</strong> It provides the high spatial resolution (~4-km) daily surface fields of temperature, precipitation, winds, humidity and radiation across the contiguous United States from 1979.
<ul>
<li><em>Dataset:</em> ee.ImageCollection(“IDAHO_EPSCOR/GRIDMET”)</li>
<li><em>Dataset Provider:</em> USDA National Agricultural Statistics Service</li>
<li><em>Data Used for our Study:</em> <code>pr</code> parameter of the dataset which provides the ‘Precipitation amount’ in mm (daily total) <br><br><br>
</li>
</ul></li>
<li><strong>Sentinel-1 SAR GRD</strong> It contains the boundary information i.e.&nbsp;counties of states which are the primary legal divisions units of US states.
<ul>
<li><em>Dataset:</em> ee.ImageCollection(“COPERNICUS/S1_GRD”)</li>
<li><em>Dataset Provider:</em> European Union/ESA/Copernicus</li>
<li><em>Data Used for our Study:</em> <code>VV</code> parameter of the dataset which provides ‘Single co-polarization, vertical transmit/vertical receive’ in dB. <br><br></li>
</ul></li>
<li><strong>SPL3SMP_E.005 SMAP L3 Radiometer Global Daily 9km Soil Moisture</strong> It provides a daily composite of global land surface conditions retrieved by the Soil Moisture Active Passive (SMAP) L-Band radiometer. The daily data here were collected from the descending (local solar time of 6 am) and ascending (local solar time of 6 pm) passes.
<ul>
<li><em>Dataset:</em> ee.ImageCollection(“NASA/SMAP/SPL3SMP_E/005”)</li>
<li><em>Dataset Provider:</em> Google and NSIDC</li>
<li><em>Data Used for our Study:</em> <code>soil_moisture_am</code> &amp; <code>soil_moisture_pm</code>parameter of the dataset which provides ’Retrieved soil moisture estimate from the disaggregated/downscaled vertical polarization brightness temperature at 9-km grid cell one at AM overpass &amp; other at PM overpass.in dB. <br><br></li>
</ul></li>
<li><strong>MOD11A1.061 Terra Land Surface Temperature</strong> MOD11A1 V6.1 product provides daily land surface temperature (LST) along with other parameters.
<ul>
<li><em>Dataset:</em> ee.ImageCollection(“NASA/SMAP/SPL3SMP_E/005”)</li>
<li><em>Dataset Provider:</em> NASA LP DAAC at the USGS EROS Center</li>
<li><em>Data Used for our Study:</em> <code>LST_Day_1km</code> &amp; <code>LST_Night_1km</code>parameter of the dataset which provides ‘Daytime Land Surface Temperature’ &amp; Daytime Land Surface Temperature’ both in Kelvin (K). <br><br></li>
</ul></li>
<li><strong>MCD18C2.061 Photosynthetically Active Radiation Daily 3 hour</strong> The MCD18C2 Version 6.1 is a Moderate Resolution Imaging Spectroradiometer (MODIS) Terra and Aqua combined Photosynthetically Active Radiation (PAR) gridded Level 3 product produced daily at 0.05 degree (5,600 meters at the equator) resolution with estimates of PAR every 3 hours.
<ul>
<li><em>Dataset:</em> ee.ImageCollection(“MODIS/061/MCD18C2”)</li>
<li><em>Dataset Provider:</em> NASA LP DAAC at the USGS EROS Center</li>
<li><em>Data Used for our Study:</em> <code>GMT_1200_PAR</code> parameter of the dataset which provides ‘Total PAR at GMT 12:00’.PAR is incident solar radiation in the visible spectrum (400-700 nanometers) and is an important variable in land-surface models having use in agriculture &amp; other scientific applications. <br><br></li>
</ul></li>
<li><strong>MOD16A2GF.061: Terra Net Evapotranspiration</strong> It includes inputs of daily meteorological reanalysis data along with MODIS remotely sensed data products such as vegetation property dynamics, albedo, and land cover. The pixel values for the two Evapotranspiration layers (ET and PET) are the sum of all eight days within the composite period, and the pixel values for the two Latent Heat layers (LE and PLE) are the average of all eight days within the composite peri.
<ul>
<li><em>Dataset:</em> ee.ImageCollection(“MODIS/061/MOD16A2GF”)</li>
<li><em>Dataset Provider:</em> NASA LP DAAC at the USGS EROS Center</li>
<li><em>Data Used for our Study:</em> <code>ET</code> parameter of the dataset which provides ‘Total evapotranspiration’ in kg/m^2/8day.s. <br><br></li>
</ul></li>
</ol>
</section>
<section id="methodology" class="level3">
<h3 class="anchored" data-anchor-id="methodology">Methodology</h3>
<p>How are you using this data to address the problem?</p>
<section id="building-random-forest-model" class="level4">
<h4 class="anchored" data-anchor-id="building-random-forest-model"><strong>Building Random Forest Model:</strong></h4>
<ol type="1">
<li><strong>Prepare original CSV including the three types of crop among several X variables and Y variable (the crop yield)</strong>
<ul>
<li><em>CSV Img!</em> <br><br><br>
</li>
</ul></li>
<li><strong>Prepare training/validation data</strong>
<ul>
<li>Add a random attribute to the data set with a random number.</li>
<li>Split 80% of data for training and 20% of that for testing.<br>
<br><br></li>
</ul></li>
<li><strong>Use the training data to train three different RF Models in GEE</strong>
<ul>
<li>ee.Classifier.smileRandomForest(100, null, 1, 0.5, null, 0).setOutputMode(‘REGRESSION’)</li>
<li>Notice ‘setOutputMode’ is set to ‘REGRESSION’. This command is the most important for running Random Forest regression models in GEE <br><br> #### <strong>Validation</strong></li>
<li>X variables</li>
<li>Importances</li>
<li>R2</li>
<li>RMSE</li>
</ul></li>
</ol>
</section>
</section>
<section id="interface" class="level3">
<h3 class="anchored" data-anchor-id="interface">Interface</h3>
<p>Here is a presentation to show, how our application work:</p>
<div style="position: relative; width: 110%; height:600px; padding-top: 56.2500%;
 padding-bottom: 0; box-shadow: 0 2px 8px 0 rgba(63,69,81,0.16); margin-top: 1.6em; margin-bottom: 0.9em; overflow: hidden;
 border-radius: 8px; will-change: transform;">
<p><iframe loading="lazy" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0; border: none; padding: 0;margin: 0;" src="https://www.canva.com/design/DAGCq_eFmq8/Muz__V20V7SJUNr3EVBSEQ/view?embed" allowfullscreen="allowfullscreen" allow="fullscreen"> </iframe></p>
</div>
</section>
</section>
<section id="the-application" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="the-application">The Application</h2>
<div class="column-page">
<iframe src="https://songzimeng.users.earthengine.app/view/north-dakota-crop-yield" width="100%" height="700px">
</iframe>
</div>
</section>
<section id="how-it-works" class="level2">
<h2 class="anchored" data-anchor-id="how-it-works">How it Works</h2>
<section id="data-extraction-code" class="level3">
<h3 class="anchored" data-anchor-id="data-extraction-code">Data Extraction Code:</h3>
<ul>
<li>Here we use the Python environment to extract the data from different datasets using Google Earth Engine API</li>
<li>Afterwards, we first use the crop-specific land cover data to distinguish different crops- wheat, soybean or corn for each county in North Dakota.</li>
<li>Further, NDVI, Precipitation, SAR, Soil Moisture &amp; other values are used to get the county-wise values from the year 2000-2024.</li>
<li>Afterwards, the Yield data is obtained from the <a href="https://quickstats.nass.usda.gov/">United States Department of Agriculture</a> for each of the years and a final dataset is obtained which has all the X Variables (GEOID,NDVI,PA,SAR,SMS_AM,LST_DAY,SMS_PM,LST_NIGHT,PAR,ET) &amp; Y variable (YIELD).</li>
</ul>
<p>```python # Commented the line below as I have installed the gee api already #pip install earthengine-api import ee ee.Authenticate() ee.Initialize() def processYear(year): # Load the CDL dataset for the given year dataset = ee.ImageCollection(‘USDA/NASS/CDL’)<br>
.filter(ee.Filter.date(f’{year}-01-01’, f’{year}-12-31’))<br>
.first() crop_landcover = dataset.select(‘cropland’)</p>
<pre><code># Filter for North Dakota counties
#`STATEFP` parameter of the dataset which provides the State FIPS code &amp; the North Dakota value is used.
counties = ee.FeatureCollection('TIGER/2016/Counties')
nd = counties.filter(ee.Filter.eq('STATEFP', '38'))

# Identify corn areas in North Dakota
#`cropland` values for different crops of our study are used Wheat, Corn &amp; Soybean Values provided from the Cropland Table.
corn = crop_landcover.eq(1).Or(crop_landcover.eq(12)).Or(crop_landcover.eq(13))
masked_corn = crop_landcover.updateMask(corn).clipToCollection(nd)

# Calculate NDVI for corn areas using MODIS data
#`NDVI` parameter of the dataset and we obtain the mean over the growth period of the crop
NDVI_dataset = ee.ImageCollection('MODIS/061/MOD13Q1')\
                .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))
ndvi = NDVI_dataset.select('NDVI')
mean_ndvi = ndvi.mean().rename('NDVI')
cornNDVI = mean_ndvi.updateMask(masked_corn)

# Calculate precipitation using GRIDMET data
#`pr` parameter of the dataset which provides the 'Precipitation amount' in mm (daily total)
precipitation_dataset = ee.ImageCollection("IDAHO_EPSCOR/GRIDMET")\
                         .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\
                         .select('pr')
mean_precipitation = precipitation_dataset.mean().rename('PA')

# Load Sentinel-1 C-band SAR Image Collection for the given year, select VV polarization
#`VV` parameter of the dataset which provides 'Single co-polarization, vertical transmit/vertical receive' in dB.
s1_dataset = ee.ImageCollection("COPERNICUS/S1_GRD")\
               .filter(ee.Filter.eq('instrumentMode', 'IW'))\
               .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))\
               .filter(ee.Filter.date(f'{year}-01-01', f'{year}-12-31'))\
               .select('VV')
mean_s1_vv = s1_dataset.mean().rename('SAR')

# Load Radiometer Global Daily 9 km Soil Moisture AM
#`soil_moisture_am` &amp; `soil_moisture_pm` parameter of the dataset which provides 'Retrieved soil moisture estimate from the
# disaggregated/downscaled vertical polarization brightness temperature at 9-km grid cell one at AM overpass &amp; other at  PM overpass. in dB.
smap_dataset = ee.ImageCollection("NASA/SMAP/SPL3SMP_E/005")\
                .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\
                .select('soil_moisture_am')
mean_soil_moisture = smap_dataset.mean().rename('SMS_AM')
# Load Radiometer Global Daily 9 km Soil Moisture PM
smapDataset_pm = ee.ImageCollection("NASA/SMAP/SPL3SMP_E/005")\
                   .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\
                   .select('soil_moisture_am')
meanSoilMoisture_pm = smapDataset_pm.mean().rename('SMS_PM')

# Load MODIS Land Surface Temperature DAY
#`LST_Day_1km` &amp; `LST_Night_1km` parameter of the dataset which provides 'Daytime Land Surface Temperature' &amp;
# Nighttime Land Surface Temperature' both in Kelvin (K).
lstDataset = ee.ImageCollection("MODIS/061/MOD11A1")\
               .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))
lstmean_celsius = lstDataset.select('LST_Day_1km')\
                            .mean()\
                            .multiply(0.02)\
                            .subtract(273.15)\
                            .rename('LST_DAY')

# Load MODIS Land Surface Temperature NIGHT
lstDataset_night = ee.ImageCollection("MODIS/061/MOD11A1")\
                     .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))
lstmean_celsius_night = lstDataset_night.select('LST_Night_1km')\
                                          .mean()\
                                          .multiply(0.02)\
                                          .subtract(273.15)\
                                          .rename('LST_NIGHT')

# Photosynthetically Active Radiation Daily 3-Hour
#`GMT_1200_PAR` parameter of the dataset which provides 'Total PAR at GMT 12:00'. PAR is incident solar radiation in
# the visible spectrum (400-700 nanometers) and is an important variable in land-surface models having use in agriculture &amp;
# other scientific applications.
par_12 = ee.ImageCollection("MODIS/061/MCD18C2")\
           .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\
           .select('GMT_1200_PAR')
mean_par_12 = par_12.mean().rename('PAR'); # Calculate the Photosynthetically Active Radiation at 12 PM

# Net Evapotranspiration
# `ET` parameter of the dataset which provides 'Total evapotranspiration' in kg/m^2/8day.s.
netevapo = ee.ImageCollection("MODIS/061/MOD16A2GF")\
             .filter(ee.Filter.date(f'{year}-05-01', f'{year}-10-01'))\
             .select('ET')

mean_netevapo = netevapo.mean().rename('ET')  # Calculate the mean Soil Moisture

# Combine all layers
combinedDataset = cornNDVI.addBands(mean_precipitation).addBands(mean_s1_vv).addBands(mean_soil_moisture).addBands(lstmean_celsius).addBands(meanSoilMoisture_pm).addBands(lstmean_celsius_night).addBands(mean_par_12).addBands(mean_netevapo)

# Reduce regions and calculate mean values over the specified areas
combined_mean = combinedDataset.reduceRegions(
 collection=nd,
 reducer=ee.Reducer.mean(),
 scale=30,
 tileScale=4,
 )

 # Define export parameters
export_params = {
    'collection': combined_mean,
    'description': f'combined_{year}',
    'folder': 'GEE_Folder',
    'fileNamePrefix': f'Combined_{year}',
    'fileFormat': 'CSV',
    'selectors': ['NAME', 'GEOID', 'NDVI', 'PA', 'SAR', 'SMS_AM', 'LST_DAY', 'SMS_PM', 'LST_NIGHT', 'PAR', 'ET']
}

# Commented the line below as I have got the data in my drive already
#ee.batch.Export.table.toDrive(**export_params).start()

# Example of processing each year
for year in range(2000, 2024):
    processYear(year)</code></pre>
</section>
<section id="methodology-code" class="level3">
<h3 class="anchored" data-anchor-id="methodology-code">Methodology Code:</h3>
</section>
<section id="interface-code" class="level3">
<h3 class="anchored" data-anchor-id="interface-code">Interface Code:</h3>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = true;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>